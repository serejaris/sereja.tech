---
title: "Семантический поиск по Telegram: мой second brain из чатов"
date: 2026-01-26
description: "Как я сделал поиск по смыслу в своих Telegram-переписках. Telethon, sqlite-vec, OpenAI embeddings — и больше никаких ctrl+F по 50 чатам."
tags:
  - вайбкодинг
  - Telegram
  - RAG
  - sqlite-vec
section: "Проекты"
---

Вася три месяца назад скинул решение бага с async — помню точно. В каком из 47 чатов — уже нет.

Пробовал Ctrl+F: "async", "await", "баг". Telegram выдал 200+ совпадений. Половина — про что угодно, только не то. Стандартный поиск ищет слова. Мне нужен смысл.

Написал инструмент за вечер: качаю сообщения, генерирую эмбеддинги, ищу по семантике. Теперь пишу "то решение с concurrent requests" — нахожу за секунду.

## Что такое семантический поиск

Обычный поиск — это точное совпадение слов. Написал "деплой" — найдёт только сообщения со словом "деплой". А если человек написал "выкатить на прод"? Не найдёт.

Семантический поиск работает иначе — превращает текст в вектор, набор из 1536 чисел. "Деплой", "выкатить на прод", "залить на сервер" оказываются рядом в этом пространстве.

Для этого нужны:
1. **Эмбеддинги** — модель, которая превращает текст в вектор
2. **Векторная база** — хранилище, которое умеет искать похожие векторы
3. **Данные** — собственно сообщения из чатов

По-моему, это редкий случай когда AI реально полезен. Не модный buzzword, а инструмент.

## Архитектура

Четыре модуля. Каждый делает одно.

```
sync.py  →  скачивает сообщения из Telegram
db.py    →  SQLite + sqlite-vec для хранения
embed.py →  генерирует эмбеддинги через OpenAI
search.py → CLI для поиска по смыслу
```

Почему отдельные файлы? Sync сломался — чиню sync. Эмбеддинги съели бюджет — вижу сразу где. А поиск вообще работает за 200мс, независимо от остального.

## Промпты для практики

Дальше — конкретные промпты, которые я писал агенту. Каждый можно скопировать и адаптировать под свой проект.

### sync.py: скачивание с rate limiting

Телеграм банит за спам к API. Это критично. Один неудачный скрипт — и аккаунт в read-only на сутки.

```
Создай sync.py для скачивания сообщений из Telegram через Telethon.

Требования:
- CLI с аргументами: --init (первая авторизация), --days N (сколько дней качать),
  --limit N (лимит чатов), --filter "строка" (фильтр по названию чата)
- Rate limiting обязателен:
  - Задержка 1-3 секунды между чатами (random)
  - Задержка 0.1-0.3 секунды внутри батча сообщений
  - При FloodWaitError — sleep на e.seconds + 10 и пропуск чата
- Сохраняй last_synced_id для каждого чата, чтобы не качать повторно
- Только текстовые сообщения (msg.text)
- Прогресс в консоль: [1/47] Syncing: Chat Name (from msg_id > 12345)

Конфиг бери из config.py: API_ID, API_HASH, SESSION_PATH, DB_PATH.
Используй Database класс из db.py для сохранения.
```

Что получилось: агент сразу заложил правильную структуру. `FloodWaitError` обрабатывается, random delays есть, прогресс показывает. За ночь синхронизировал 60 дней из 50 чатов — ни одного бана.

Ключевой момент — "Rate limiting обязателен". Без этой фразы агент может сделать наивную версию без задержек.

### db.py: SQLite + sqlite-vec

Выбрал sqlite-vec вместо Pinecone/Weaviate. Причины простые: один файл, нет сервера, бэкап = копирование.

```
Создай db.py — модуль базы данных с sqlite-vec для векторного поиска.

Требования:
- Класс Database с методами:
  - upsert_chat(id, title, type, username)
  - insert_messages(list[dict]) — батч, игнорировать дубликаты
  - get_last_synced_id(chat_id) → int
  - update_last_synced_id(chat_id, msg_id)
  - insert_embeddings_batch(rowids, embeddings)
  - get_messages_without_embeddings(limit) → list
  - search_similar(query_embedding, limit) → list с distance

Схема:
- chats: id, title, type, username, last_synced_id
- messages: rowid, id, chat_id, sender_id, sender_name, text, date
- vec_messages: message_rowid, embedding FLOAT[1536]

Критично для sqlite-vec:
- KNN запрос: WHERE embedding MATCH ? AND k = ?
- НЕ использовать LIMIT для KNN — только k = ?
- Эмбеддинг упаковывать через struct.pack

Загружай расширение через sqlite_vec.load(conn).
```

Важный момент — "НЕ использовать LIMIT для KNN". Это особенность sqlite-vec. Обычный SQL паттерн не работает, нужен `k = ?`. Агент может не знать этого, поэтому указываю явно.

### embed.py: батчи эмбеддингов

OpenAI позволяет отправлять до 2048 текстов за раз. Но я делаю по 100 — так проще отлаживать и видеть прогресс.

```
Создай embed.py для генерации эмбеддингов через OpenAI API.

Требования:
- Функции:
  - embed_batch(texts: list[str]) → list[list[float]]
  - embed_single(text: str) → list[float]
  - process_messages(db, batch_size=100, limit=0)
- CLI: --batch N (размер батча), --limit N (лимит сообщений, 0=все)
- Прогресс: "Embedding 100 messages... Processed: 500 total"
- Модель из config.py: EMBEDDING_MODEL (text-embedding-3-small)

Алгоритм process_messages:
1. Получи сообщения без эмбеддингов (get_messages_without_embeddings)
2. Сгенерируй эмбеддинги батчом
3. Сохрани через insert_embeddings_batch
4. Повторяй пока есть сообщения

Показывай сколько осталось необработанных при старте.
```

Результат: 15k сообщений обработались за 10 минут. $0.02 за весь архив — text-embedding-3-small дешёвый.

### search.py: CLI поиск

Финальный модуль — то, ради чего всё затевалось.

```
Создай search.py — CLI для семантического поиска по сообщениям.

Требования:
- CLI: python search.py "запрос" [-n 10] [-c "chat filter"]
- Алгоритм:
  1. Получи эмбеддинг запроса через embed_single
  2. Найди похожие через db.search_similar
  3. Выведи результаты красиво

Формат вывода:
1. [Chat Name] Sender Name (2024-01-15 14:30) - 87.5%
   Текст сообщения (обрезать до 150 символов)...

- Similarity = (1 - distance) * 100
- Дата в формате YYYY-MM-DD HH:MM
- Разделитель между результатами
```

Теперь `python search.py "решение с rate limiting"` выдаёт именно то сообщение от Васи.

## Как использую

```bash
# Синхронизация за последнюю неделю
python sync.py --days 7 --limit 20

# Эмбеддинги для новых сообщений
python embed.py --batch 100

# Поиск
python search.py "что обсуждали про деплой"
python search.py "рекомендация книги от Пети"
python search.py "тот скрипт для парсинга"
```

Раньше на такой поиск уходило минут 15. Теперь — секунда в терминале.

## Типичные ошибки

### Ошибка 1: Забыл rate limiting

Первая версия качала без задержек. В 2 ночи Telegram выдал FloodWait на 2 часа. Не забанили, но было неприятно.

{{< callout warning "Правило" >}}
Всегда закладывай random delays между запросами к Telegram API. Не 1 секунда — а random(1, 3). Детерминированные паттерны легче детектятся.
{{< /callout >}}

### Ошибка 2: LIMIT вместо k в sqlite-vec

Классический SQL:
```sql
SELECT * FROM vec_messages ORDER BY distance LIMIT 10
```

Не работает. sqlite-vec требует:
```sql
WHERE embedding MATCH ? AND k = 10
```

Агент может не знать этого. Если поиск выдаёт странные результаты — проверь синтаксис KNN запроса.

### Ошибка 3: Один большой batch для эмбеддингов

Можно отправить 2048 текстов за раз. Но если один из них битый — весь запрос падает. Батчи по 100 безопаснее: легче найти проблемный текст, прогресс виден чаще.

### Ошибка 4: Хранение API ключей в коде

Агент может захардкодить ключи прямо в скрипт. Проверяй. Всегда:
```python
from config import OPENAI_API_KEY
```

И `.env` в `.gitignore`.

## Расширения

Базовая версия работает. Но можно добавить:

**Hybrid search** — векторы + FTS5 для точных совпадений. Если ищешь конкретный URL или код — FTS5 найдёт точнее.

**MCP-сервер** — чтобы Claude Code искал по переписке прямо из терминала. "Что Вася писал про деплой?" — и агент сам вызывает поиск.

**Локальные эмбеддинги** — ollama вместо OpenAI для приватности. Медленнее, но данные не уходят на внешний сервер.

## Упражнение

Попробуй адаптировать под свой источник данных:

1. **Slack** — похожая структура: каналы = чаты, сообщения = сообщения
2. **Discord** — discord.py вместо Telethon, остальное идентично
3. **Email** — IMAP для скачивания, тема + тело = текст для эмбеддинга
4. **Заметки** — Obsidian/Notion export в markdown, каждый файл = сообщение

Начни с малого: 100 сообщений, один чат. Убедись что поиск работает. Потом масштабируй.

Семантический поиск — конкретная технология. Скачал → эмбеддинги → поиск. Каждый шаг отлаживается отдельно.

---

## Источники

- [telegram-search](https://github.com/groupultra/telegram-search) — похожий проект с 3.7k звёзд
- [sqlite-vec](https://github.com/asg017/sqlite-vec) — векторное расширение для SQLite
- [How sqlite-vec Works](https://medium.com/@stephenc211/how-sqlite-vec-works-for-storing-and-querying-vector-embeddings-165adeeeceea) — подробный разбор
- [RAG in SQLite](https://towardsdatascience.com/retrieval-augmented-generation-in-sqlite/) — туториал по RAG на sqlite-vec
- [Telegram 429 handling](https://pcg-telegram.com/blogs/893) — rate limiting в 2025-2026
