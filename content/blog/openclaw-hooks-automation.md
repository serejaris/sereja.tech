---
title: "Не модель делает агента полезным, а то, что вокруг"
date: 2026-02-17
description: "Хуки в OpenClaw — слой автоматизации между событиями агента и внешним миром. Без них агент отвечает на вопросы, с ними — действует автономно, без участия LLM."
tags: ["openclaw", "hooks", "автоматизация"]
image: "/images/blog/openclaw-hooks-automation-preview.png"
---

Хуки в OpenClaw — это код, который срабатывает на события агента без участия LLM. Старт, новая сессия, выполнение команды — на каждое событие можно повесить автоматическое действие. Загрузить контекст, сохранить снапшот, записать в лог. Никаких промптов, никаких токенов. Я настроил три хука и агент перестал забывать, кто он.

## Проблема: агент без памяти

В [первой части](/blog/openclaw-vps-6-dollars) я поставил OpenClaw на VPS за $6. Агент жил на сервере, отвечал в Telegram, называл меня самураем. Всё красиво.

Но через пару дней я заметил паттерн. Каждое утро я писал боту одно и то же: «Напомни, что мы вчера делали». Он не помнил. Каждая сессия начиналась с чистого листа — агент терял контекст при `/new`.

Ещё хуже: я не знал, какие команды агент выполнял, пока я спал. Он мог что-то удалить, что-то установить, что-то сломать — и единственный способ узнать это был ручной просмотр терминала.

Чат-бот, который забывает всё после перезагрузки. Не помощник.

Я уже проходил через это с [пайплайнами на скиллах](/blog/pipeline-reliability-state-persistence) — без сохранения состояния любая система одноразовая. Там помогло записывать прогресс после каждого шага. Здесь нужно то же самое, только для агента целиком.

Мне нужно было три вещи:

1. Агент при старте знает, кто он и что делал раньше
2. Сессии не теряются при `/new`
3. Все команды логируются автоматически

## Что такое хуки

Хуки — отдельный слой поверх агента. Они выполняются при конкретных событиях: старт gateway, новая сессия, выполнение команды. LLM в этот момент не участвует — это обычный TypeScript-код, который срабатывает по триггеру.

Аналогия из мира разработки — git hooks. `pre-commit` проверяет код до коммита, `post-merge` запускает миграции после мержа. Ты не вызываешь их руками — они срабатывают автоматически, когда происходит событие.

В OpenClaw — та же идея, только события другие:

```
Без хуков:                          С хуками:

┌──────────┐                        ┌──────────┐
│   Ты     │                        │   Ты     │
│ (промпт) │                        │ (промпт) │
└────┬─────┘                        └────┬─────┘
     │                                   │
     ▼                                   ▼
┌──────────┐                        ┌──────────────────────────┐
│   LLM    │                        │        Хуки              │
│          │                        │                          │
│ Думает → │                        │  gateway:startup         │
│ Отвечает │                        │    → загрузить BOOT.md   │
│          │                        │  command:new             │
└──────────┘                        │    → сохранить сессию    │
                                    │  command (любая)         │
     Агент реагирует                │    → записать в лог      │
     только на промпты.             └────────────┬─────────────┘
     Забывает всё                                │
     между сессиями.                             ▼
                                    ┌──────────────────────────┐
                                    │          LLM             │
                                    │                          │
                                    │  Стартует с контекстом.  │
                                    │  Сессии сохраняются.     │
                                    │  Команды логируются.     │
                                    └──────────────────────────┘
```

Два типа автоматизации: **Hooks** — внутренние обработчики событий внутри Gateway, и **Webhooks** — внешние HTTP-эндпоинты, через которые другие системы могут триггерить работу в OpenClaw. Сегодня — про первые.

## Как устроены хуки под капотом

Попросил агента объяснить, как хуки организованы. Каждый хук — это описание (на какие события реагировать) и реализация (что делать). Мне не нужно в это лезть, но понимать архитектуру полезно.

Хуки загружаются по приоритету: сначала из папки проекта, потом глобальные, потом встроенные. Проектные перекрывают глобальные — можно переопределить поведение для конкретной задачи, не ломая остальное.

## Настройка: три промпта

Я не трогал TypeScript руками. Написал агенту три сообщения.

### Шаг 1: сохранение сессий

Первое, что хотелось исправить — потеря контекста при `/new`. Каждая новая сессия стирала предыдущую.

Написал OpenClaw в Telegram:

{{< callout type="insight" >}}
Включи session-memory хук — хочу, чтобы при каждом /new агент сохранял снапшот сессии.
{{< /callout >}}

Агент включил встроенный хук `session-memory`. Теперь при каждом `/new` хук создаёт датированный файл с контекстом предыдущей сессии — что обсуждали, какие решения приняли, что осталось незакрытым.

Результат: утром я пишу `/new`, и агент уже знает, чем мы занимались вчера. Не потому что LLM "запомнил" — а потому что хук сохранил снапшот, и агент загрузил его при старте.

### Шаг 2: контекст при запуске

Снапшоты сессий — хорошо. Но агент при старте не знал даже базовых вещей: какой у него системный промпт, какие проекты в работе, какие ограничения.

{{< callout type="insight" >}}
Настрой boot-md так, чтобы при старте агент читал BOOT.md и знал своё текущее состояние.
{{< /callout >}}

Агент включил хук `boot-md`. Он срабатывает на `gateway:startup` — при каждом запуске gateway читается файл `BOOT.md` и его содержимое инжектится в контекст. Туда можно положить что угодно: текущие задачи, правила поведения, список проектов.

Это как `CLAUDE.md` для Claude Code — только для OpenClaw-агента на сервере. Один файл, который определяет, с каким контекстом агент начинает работу.

### Шаг 3: аудит

Последний кусок — логирование. Агент выполняет команды на сервере. Я хочу знать, какие именно.

{{< callout type="insight" >}}
Покажи, какие хуки уже включены и что каждый из них делает.
{{< /callout >}}

Агент запустил `openclaw hooks list` и показал список. Среди включённых оказался `command-logger` — он записывает каждую выполненную команду в лог-файл. Дата, время, что именно выполнилось. Аудит из коробки.

Три промпта. Ноль написанного вручную кода. Поведение агента изменилось кардинально.

## Что ещё есть из коробки

OpenClaw поставляется с набором встроенных хуков. Те, что я использую:

- **session-memory** — снапшот сессии при `/new`. Событие: `command:new`
- **boot-md** — загрузка `BOOT.md` при старте. Событие: `gateway:startup`
- **command-logger** — лог всех команд в структурированном формате. Событие: `command`

И ещё пара интересных:

- **bootstrap-extra-files** — инжект дополнительных файлов в контекст при `agent:bootstrap`. Полезно для монорепо, когда агенту нужно знать про несколько проектов
- **soul-evil** — подмена личности агента по расписанию или с заданной вероятностью. Я пока не пробовал, но идея интересная — можно тестировать, как агент ведёт себя с другим характером

Управление — через CLI: `openclaw hooks list` покажет что установлено, `openclaw hooks info <name>` — детали конкретного хука.

## Результат

До хуков: агент — это чат. Задал вопрос — получил ответ. Закрыл сессию — всё забыл. Что делал ночью — неизвестно.

После хуков:

- **Старт:** агент читает `BOOT.md`, знает контекст, задачи, ограничения
- **Новая сессия:** снапшот предыдущей сохраняется автоматически, ничего не теряется
- **Каждая команда:** логируется, можно посмотреть историю за любой день
- **Поведение:** предсказуемое. Агент не начинает с нуля, не "забывает", не теряет контекст

Модель та же — Kimi K2.5. Но поведение другое. По-моему, это главное наблюдение: не модель определяет полезность агента, а инфраструктура вокруг неё.

## Хуки — это архитектура, а не код

Хуки — не про TypeScript. Они про то, какие события ловить и что делать в ответ. Git hooks делают то же для репозитория, n8n-воркфлоу — для бизнес-процессов. Принцип один: «когда произошло X — сделай Y».

Я описывал этот подход в посте про [event-driven агентов](/blog/personal-corporation-event-driven-agents) — система реагирует на события, а не ждёт команд. Хуки — конкретная реализация этой идеи внутри одного агента.

Событие → хук → действие. LLM не задействован, токены не потрачены. Для вайбкодера в этом вся суть: не нужно разбираться в TypeScript — нужно понимать, какое поведение хочешь, и попросить агента настроить.

---

## FAQ

### Чем хуки OpenClaw отличаются от обычных git hooks?

Принцип тот же — код срабатывает на событие автоматически. Разница в событиях: git hooks реагируют на операции с репозиторием (commit, push, merge), хуки OpenClaw — на события агента (старт, новая сессия, выполнение команды). Архитектура одинаковая, контекст разный.

### Нужно ли знать TypeScript, чтобы писать свои хуки?

Для встроенных — нет. Включаешь через `openclaw hooks enable`, настраиваешь через конфиг. Для кастомных хуков нужен `handler.ts` — но можно попросить агента написать его по описанию. Я ни строчки TypeScript не написал руками.

### Тратят ли хуки токены LLM?

Нет. Хуки — это обычный TypeScript-код, который выполняется при событии. LLM не вызывается. Ноль токенов, мгновенное выполнение. Именно поэтому хуки подходят для высокочастотных операций вроде логирования каждой команды.

### Можно ли писать свои хуки или только использовать встроенные?

Можно и то, и другое. Встроенные покрывают базовые сценарии: память сессий, загрузка контекста, логирование. Свои хуки можно положить в папку проекта или в `~/.openclaw/hooks/` для глобального использования. Установить сторонний хук — `openclaw hooks install <path>`.
